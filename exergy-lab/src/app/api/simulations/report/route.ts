/**
 * Simulations Report API
 *
 * POST /api/simulations/report
 *
 * Generates a comprehensive PDF report for a completed simulation.
 * Returns the report as a base64-encoded PDF or download URL.
 */

import { NextRequest, NextResponse } from 'next/server'
import { generateSimulationPDF } from '@/lib/simulation-pdf-generator'
import type { SimulationReportData, SimulationReportConfig } from '@/types/simulation-report'

// ============================================================================
// Request/Response Types
// ============================================================================

interface ReportRequest {
  reportData: SimulationReportData
  config?: Partial<SimulationReportConfig>
  format?: 'pdf' | 'html' | 'json'
  filename?: string
}

interface ReportResponse {
  success: boolean
  format: string
  filename: string
  data?: string // Base64 encoded PDF or raw JSON/HTML
  contentType?: string
  size?: number // File size in bytes
  error?: string
}

// ============================================================================
// Helpers
// ============================================================================

/**
 * Generate a filename for the report
 */
function generateFilename(reportData: SimulationReportData, format: string): string {
  const title = reportData.metadata.title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 50)

  const date = new Date().toISOString().split('T')[0]
  return `exergy-simulation-${title}-${date}.${format}`
}

/**
 * Convert report data to HTML
 */
function generateHTMLReport(reportData: SimulationReportData): string {
  const { metadata, overview, methodology, results, conclusions } = reportData

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${metadata.title} - Exergy Lab Simulation Report</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.6; color: #1a1a2e; }
    h1 { color: #0066cc; border-bottom: 2px solid #0066cc; padding-bottom: 0.5rem; }
    h2 { color: #333; margin-top: 2rem; }
    h3 { color: #666; }
    .meta { color: #666; font-size: 0.9rem; margin-bottom: 2rem; }
    .section { margin-bottom: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid #ddd; }
    th { background: #e9ecef; }
    .metric { display: inline-block; padding: 0.5rem 1rem; margin: 0.25rem; background: #e7f1ff; border-radius: 4px; }
    .metric-value { font-weight: bold; color: #0066cc; }
    .footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #ddd; color: #666; font-size: 0.8rem; text-align: center; }
  </style>
</head>
<body>
  <h1>${metadata.title}</h1>
  <div class="meta">
    <p>Domain: ${metadata.domain} | Generated: ${new Date(metadata.createdAt).toLocaleDateString()}</p>
    ${metadata.author ? `<p>Author: ${metadata.author}</p>` : ''}
  </div>

  <div class="section">
    <h2>Executive Summary</h2>
    <p>${overview.description}</p>
    ${overview.goals.length > 0 ? `
    <h3>Goals</h3>
    <ul>
      ${overview.goals.map((g) => `<li>${g}</li>`).join('')}
    </ul>
    ` : ''}
  </div>

  <div class="section">
    <h2>Methodology</h2>
    <p><strong>Simulation Type:</strong> ${methodology.simulationType}</p>
    <p><strong>Tier:</strong> ${methodology.tier}</p>
    <p><strong>Provider:</strong> ${methodology.provider}</p>
    <p>${methodology.description}</p>

    ${methodology.parameters.length > 0 ? `
    <h3>Parameters</h3>
    <table>
      <tr><th>Name</th><th>Value</th><th>Unit</th></tr>
      ${methodology.parameters.map((p) => `<tr><td>${p.name}</td><td>${p.value}</td><td>${p.unit}</td></tr>`).join('')}
    </table>
    ` : ''}
  </div>

  <div class="section">
    <h2>Results</h2>
    <div>
      ${results.metrics.map((m) => `
        <span class="metric">
          <span>${m.name}:</span>
          <span class="metric-value">${m.value} ${m.unit}</span>
        </span>
      `).join('')}
    </div>
  </div>

  <div class="section">
    <h2>Conclusions</h2>
    <p>${conclusions.summary}</p>

    ${conclusions.keyFindings.length > 0 ? `
    <h3>Key Findings</h3>
    <ul>
      ${conclusions.keyFindings.map((f) => `<li>${f}</li>`).join('')}
    </ul>
    ` : ''}

    ${conclusions.limitations.length > 0 ? `
    <h3>Limitations</h3>
    <ul>
      ${conclusions.limitations.map((l) => `<li>${l}</li>`).join('')}
    </ul>
    ` : ''}
  </div>

  <div class="footer">
    <p>Generated by Exergy Lab | ${new Date().toISOString()}</p>
    <p>Report ID: ${metadata.id}</p>
  </div>
</body>
</html>`
}

// ============================================================================
// API Handler
// ============================================================================

export async function POST(request: NextRequest): Promise<NextResponse<ReportResponse>> {
  try {
    const body = (await request.json()) as ReportRequest
    const { reportData, config, format = 'pdf', filename: customFilename } = body

    // Validate report data
    if (!reportData || !reportData.metadata || !reportData.results) {
      return NextResponse.json(
        {
          success: false,
          format,
          filename: '',
          error: 'Invalid report data: missing required fields',
        },
        { status: 400 }
      )
    }

    const filename = customFilename || generateFilename(reportData, format)

    switch (format) {
      case 'pdf': {
        // Generate PDF using the simulation PDF generator
        const pdfBlob = await generateSimulationPDF(reportData, {
          config: config as SimulationReportConfig,
          format: 'pdf',
        })

        // Convert blob to base64
        const arrayBuffer = await pdfBlob.arrayBuffer()
        const base64 = Buffer.from(arrayBuffer).toString('base64')

        return NextResponse.json({
          success: true,
          format: 'pdf',
          filename,
          data: base64,
          contentType: 'application/pdf',
          size: arrayBuffer.byteLength,
        })
      }

      case 'html': {
        const html = generateHTMLReport(reportData)

        return NextResponse.json({
          success: true,
          format: 'html',
          filename: filename.replace('.pdf', '.html'),
          data: html,
          contentType: 'text/html',
          size: new TextEncoder().encode(html).length,
        })
      }

      case 'json': {
        const json = JSON.stringify(reportData, null, 2)

        return NextResponse.json({
          success: true,
          format: 'json',
          filename: filename.replace('.pdf', '.json'),
          data: json,
          contentType: 'application/json',
          size: new TextEncoder().encode(json).length,
        })
      }

      default:
        return NextResponse.json(
          {
            success: false,
            format,
            filename: '',
            error: `Unsupported format: ${format}`,
          },
          { status: 400 }
        )
    }
  } catch (error) {
    console.error('Report generation failed:', error)
    return NextResponse.json(
      {
        success: false,
        format: 'pdf',
        filename: '',
        error: error instanceof Error ? error.message : 'Report generation failed',
      },
      { status: 500 }
    )
  }
}

/**
 * GET /api/simulations/report
 * Returns information about the report API
 */
export async function GET(): Promise<NextResponse> {
  return NextResponse.json({
    description: 'Simulations Report API',
    supportedFormats: ['pdf', 'html', 'json'],
    endpoints: {
      POST: {
        description: 'Generate a simulation report',
        body: {
          reportData: 'SimulationReportData (required) - The simulation report data',
          config: 'Partial<SimulationReportConfig> (optional) - Report configuration options',
          format: 'pdf | html | json (optional, default: pdf)',
          filename: 'string (optional) - Custom filename for the report',
        },
        returns: {
          success: 'boolean',
          format: 'string',
          filename: 'string',
          data: 'string (base64 for PDF, raw for HTML/JSON)',
          contentType: 'string',
          size: 'number (bytes)',
        },
      },
    },
    reportSections: [
      'Cover Page',
      'Table of Contents',
      'Executive Summary',
      'Introduction',
      'Experiment Source',
      'Methodology',
      'Results',
      'Visualizations',
      'Exergy Analysis',
      'AI Insights',
      'Sensitivity Analysis',
      'Validation',
      'Conclusions',
      'Limitations',
      'Recommendations',
      'References',
      'Appendix',
    ],
  })
}
